import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,o as t,c as p,d as o,f as n}from"./app-BofQRgQ0.js";const c={},l=n('<h2 id="继承的概念" tabindex="-1"><a class="header-anchor" href="#继承的概念"><span><strong>继承的概念</strong></span></a></h2><p>当我们发现某两个类中的非常相似，并且可以用相似的类去抽象构造，此时我们可以使用<strong>继承</strong>来减少书写重复代码，从而提高代码编写的效率。同时，降低代码相似度，从而易于后续的代码维护。</p><p>在程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。例如：我们想要创建一个存放东西的数据库，里面所有的东西都可以称为一种 <code>item</code>，而具体物品有两种为 <code>CD</code>和 <code>DVD</code></p>',3),i=n(`<h3 id="extends" tabindex="-1"><a class="header-anchor" href="#extends"><span><code>extends</code></span></a></h3><p>在Java中使用 <code>extends</code>关键字实现继承</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">CD</span> <span class="token keyword">extends</span> <span class="token class-name">Item</span><span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token comment">//不需要重复定义Item中已经有的字段，只需要新增新的字段</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们将 <code>CD</code>这样的类称为<strong>子类/扩展类</strong>，而 <code>Item</code>称为<strong>父类/超类</strong>，子类和父类的关系是一种相对的概念，一个类既可以是某个类的子类，也可以是另一个类的父类。</p><p>在Java中，类只支持<strong>单继承</strong>，不支持<strong>多继承</strong>，即一个类只能有一个直接父类，一个类不能同时继承两个类，并且<strong>Java中所有的类都默认继承 <code>Object</code>类</strong></p><div class="hint-container caution"><p class="hint-container-title">注意</p><p>子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</p></div><h2 id="protected访问属性" tabindex="-1"><a class="header-anchor" href="#protected访问属性"><span><strong><code>protected</code>访问属性</strong></span></a></h2><p>当父类中的某个变量的访问属性为 <code>private</code>时，子类可以继承获得该变量，但是不能访问它，使用 <code>protected</code>访问属性，可以使子类获得访问父类中变量的权限。但是这样不好，如果子类和父类<strong>不在同一个包</strong>中，也无法访问到 解决办法： 我们可以将父类的变量在父类中初始化完成，再让子类获得该变量</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Item</span><span class="token punctuation">{</span>
   <span class="token keyword">private</span> title<span class="token punctuation">;</span>
   <span class="token keyword">public</span> <span class="token class-name">Item</span><span class="token punctuation">(</span><span class="token class-name">String</span> title<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在子类的构造函数中通过 <code>super()</code>使用父类的构造函数对 <code>title</code>进行初始化</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">CD</span> <span class="token keyword">extends</span> <span class="token class-name">Item</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">CD</span><span class="token punctuation">(</span><span class="token class-name">String</span> title<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="super-关键字" tabindex="-1"><a class="header-anchor" href="#super-关键字"><span><strong><code>super()</code>关键字</strong></span></a></h2><p>当子类重写父类的方法后，子类对象将无法访问父类被重写的方法，为了解决这个问题，Java提供了 <code>super()</code>关键字。</p><h3 id="调用父类构造器" tabindex="-1"><a class="header-anchor" href="#调用父类构造器"><span>调用父类构造器</span></a></h3><p>当子类对象被创建时，构造器会首先调用父类的构造器。这是为了确保父类部分的初始化在子类部分之前完成。 初始化子类对象的顺序应为：父类属性赋值-&gt;父类构造函数-&gt;子类属性赋值-&gt;子类构造函数</p><h4 id="使用-super" tabindex="-1"><a class="header-anchor" href="#使用-super"><span>使用 <code>super()</code></span></a></h4><ul><li><code>super()</code>: 调用父类的无参构造器</li><li><code>super(&lt;参数&gt;)</code>: 调用父类的带参数的构造器</li></ul><p>如果子类构造器中<mark>没有显式调用</mark> <code>super()</code> 或 <code>super(&lt;参数&gt;)</code>，编译器会在子类构造器的第一行<strong>隐式地调用</strong>父类的无参构造器，即 <code>super()</code></p><p>通过 <code>super()</code>调用父类构造方法的代码必须位于子类构造方法的第一行，并且只能出现一次</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>即在子类的构造函数中，第一行写了 <code>super()</code>和不写的效果是一样的。但是如果父类没有无参构造器，而子类没有显式调用带参数的父类构造器，则会编译错误。</p></div><h3 id="访问父类成员" tabindex="-1"><a class="header-anchor" href="#访问父类成员"><span>访问父类成员</span></a></h3><p><code>super</code>关键字也用于访问父类的成员（字段和方法），特别是在子类中有与父类同名的成员时。</p><h4 id="访问父类的字段和方法" tabindex="-1"><a class="header-anchor" href="#访问父类的字段和方法"><span>访问父类的字段和方法</span></a></h4><ul><li><code>super.&lt;父类成员&gt;</code>: 引用父类的成员。</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  
    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Parent display&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
  
    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用父类的方法</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Child display&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    <span class="token keyword">void</span> <span class="token function">showNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Parent num: &quot;</span> <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问父类的字段</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Child num: &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问子类的字段</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Child</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        child<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: Parent display</span>
                         <span class="token comment">//         Child display</span>
        child<span class="token punctuation">.</span><span class="token function">showNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: Parent num: 10</span>
                         <span class="token comment">//         Child num: 20</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><code>super()</code>和 <code>this</code>的区别</strong></p><table><thead><tr><th>区别点</th><th><code>this</code></th><th><code>super</code></th></tr></thead><tbody><tr><td>属性访问</td><td>访问本类中的属性，如果本类中没有该属性，则从父类中查找</td><td>直接访问父类中的属性</td></tr><tr><td>方法</td><td>访问本类中的方法，如果本类中没有改方法，则从父类中继续查找</td><td>直接访问父类中的方法</td></tr><tr><td>调用构造</td><td>调用本类构造，必须放在构造方法的首行</td><td>调用父类构造，必须放在子类构造方法的首行</td></tr></tbody></table><div class="hint-container important"><p class="hint-container-title">重要</p><p><code>this</code>和 <code>super()</code>不可以同时出现，因为在调用构造方法时都要求必须放在构造方法的首行</p></div><h2 id="子类和子类型" tabindex="-1"><a class="header-anchor" href="#子类和子类型"><span><strong>子类和子类型</strong></span></a></h2><p>在面向对象编程中，类是对对象的抽象描述，它定义了对象的属性和行为。子类是从父类继承而来的，它扩展了父类的属性和行为，形成了一个新的类型，这个新类型被称为子类型。所以<strong>类定义了类型，子类定义了子类型</strong></p><p>子类的对象可以被当作父类的对象来使用，具体可以表现为：</p><ul><li>赋值给父类的变量（父类的对象管理者可以管理子类的对象）</li><li>传递给需要父类变量的函数</li><li>放进存放父类对象的容器里</li></ul>`,32);function d(u,r){const s=e("Mermaid");return t(),p("div",null,[l,o(s,{id:"mermaid-9",code:"eJyNjzEKAjEQRfs9xYCNFnsBCwtNs7ViH5MhDiQZSUYR1LubjYWBFdwp3398/hivc1akXdKhg3KWEhohjrA9VFANGAQDPCoYr4e9JIoOhMTjFOurnDk1/MTsUUdwLINMfcMhYPwGC7gULssV3Jhsxa9mzU41W/646jhLLpV9/9x8Hl3jXTDaXJOx4EfUvQG481OL"}),i])}const v=a(c,[["render",d],["__file","5.html.vue"]]),h=JSON.parse('{"path":"/zh/posts/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.html","title":"继承","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","title":"继承","date":"2024-05-17T00:00:00.000Z","category":["面向对象"],"tag":["学习笔记"],"description":"继承的概念 当我们发现某两个类中的非常相似，并且可以用相似的类去抽象构造，此时我们可以使用继承来减少书写重复代码，从而提高代码编写的效率。同时，降低代码相似度，从而易于后续的代码维护。 在程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。例如：我们想要创建一个存放东西的数据库，里面所有的东西都可以称为一种 item，而...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/zh/posts/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.html"}],["meta",{"property":"og:site_name","content":"岁杪二四"}],["meta",{"property":"og:title","content":"继承"}],["meta",{"property":"og:description","content":"继承的概念 当我们发现某两个类中的非常相似，并且可以用相似的类去抽象构造，此时我们可以使用继承来减少书写重复代码，从而提高代码编写的效率。同时，降低代码相似度，从而易于后续的代码维护。 在程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。例如：我们想要创建一个存放东西的数据库，里面所有的东西都可以称为一种 item，而..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"岁杪二四"}],["meta",{"property":"article:tag","content":"学习笔记"}],["meta",{"property":"article:published_time","content":"2024-05-17T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"继承\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-17T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"岁杪二四\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"继承的概念","slug":"继承的概念","link":"#继承的概念","children":[{"level":3,"title":"extends","slug":"extends","link":"#extends","children":[]}]},{"level":2,"title":"protected访问属性","slug":"protected访问属性","link":"#protected访问属性","children":[]},{"level":2,"title":"super()关键字","slug":"super-关键字","link":"#super-关键字","children":[{"level":3,"title":"调用父类构造器","slug":"调用父类构造器","link":"#调用父类构造器","children":[]},{"level":3,"title":"访问父类成员","slug":"访问父类成员","link":"#访问父类成员","children":[]}]},{"level":2,"title":"子类和子类型","slug":"子类和子类型","link":"#子类和子类型","children":[]}],"git":{},"readingTime":{"minutes":4.62,"words":1387},"filePathRelative":"zh/posts/Java面向对象/5.md","localizedDate":"2024年5月17日","excerpt":"<h2><strong>继承的概念</strong></h2>\\n<p>当我们发现某两个类中的非常相似，并且可以用相似的类去抽象构造，此时我们可以使用<strong>继承</strong>来减少书写重复代码，从而提高代码编写的效率。同时，降低代码相似度，从而易于后续的代码维护。</p>\\n<p>在程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。例如：我们想要创建一个存放东西的数据库，里面所有的东西都可以称为一种 <code>item</code>，而具体物品有两种为 <code>CD</code>和 <code>DVD</code></p>\\n<h3><code>extends</code></h3>","autoDesc":true}');export{v as comp,h as data};
